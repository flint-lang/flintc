use Core.math

use "raylib.ft"
use "player.ft"
use "cpu.ft"

data DBall:
	f32x2 pos;
	f32x2 dir;
	f32 speed;
	f32 radius;
	DColor color;
	DBall(pos, dir, speed, radius, color);

func FBall requires(DBall ball):
	def get_x() -> f32:
		return ball.pos.x;

	def get_y() -> f32:
		return ball.pos.y;

	def get_radius() -> f32:
		return ball.radius;

	def draw():
		DrawCircle(i32(ball.pos.x), i32(ball.pos.y), ball.radius, ball.color);

	def update(f32 delta):
		ball.pos = ball.pos + ball.dir * (delta * ball.speed, delta * ball.speed);
		if (ball.pos.y + ball.radius > f32(GetScreenHeight())) or (ball.pos.y - ball.radius < 0.0):
			FBall.reflect_h(ball);

	def reset():
		i32 angle_deg = GetRandomValue(-40, 40);
		i32 left_or_right = GetRandomValue(0, 1);
		angle_deg += 180 * left_or_right;
		const f32 pi = 3.141592;
		const f32 angle_rad = f32(angle_deg * 180) / pi;
		f32x2 ball_dir = (cos(angle_rad), sin(angle_rad));

		ball.speed = 400.0;
		ball.dir = ball_dir;
		ball.pos = f32x2(GetScreenWidth() / 2, GetScreenHeight() / 2);

	/// @brief Reflects the ball along the vertical axis, so when it collided with p1 or p2
	def reflect_v():
		ball.dir = ball.dir * (-1.0, 1.0);
		ball.speed = ball.speed * 1.1;

	/// @brief Reflects the ball along the horizontal axis, so when it collided with the top or bottom of the screen
	def reflect_h():
		ball.dir = ball.dir * (1.0, -1.0);

	def passed_cpu(mut Cpu cpu) -> bool:
		return ball.pos.x - ball.radius < cpu.get_x();

	def passed_player(mut Player player) -> bool:
		return ball.pos.x + ball.radius > player.get_x();

entity Ball:
	data: DBall;
	func: FBall;
	Ball(DBall);
