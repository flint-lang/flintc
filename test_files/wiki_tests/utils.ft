use Core.system
use Core.assert
use Core.print

/// @brief Checks whether a given string starts with the given other string
///
/// @brief `string` The string to check
/// @brief `check` The string with which the other string may start with
/// @return `bool` Whether the `string` starts with `check`
def starts_with(str string, str check) -> bool:
	if string.length < check.length:
		return false;
	const bool is_ok = string[..check.length] == check;
	if not is_ok:
		print($"expected:\n{check}\n");
		print($"but got:\n{string}\n");
		print("\n");
	return is_ok;

/// @brief Compiles a given file and expects compilation to succeed. The compiled program
///        is expected to have the given expected output.
///
/// @param `file` The file to compile
/// @param `expected_output` The expected output of the compiled program
def test_file_ok(str file, str expected_output):
	(exit_code, output) := system_command($"flintc --file {file}");
	if exit_code != 0:
		print($"UNEXPECTED_CMP: exit_code = {exit_code}\n");
	assert(exit_code == 0);
	if output != "":
		print($"UNEXPECTED_CMP: output = '{output}'\n");
	assert(output == "");
	(exit_code, output) = system_command("./main");
	if exit_code != 0:
		print($"UNEXPECTED_EXE: exit_code = {exit_code}\n");
	assert(exit_code == 0);
	if output != expected_output:
		print($"UNEXPECTED_EXE: output = '{output}'\n");
		print($"EXPECTED_EXE: output = '{expected_output}'\n");
	assert(output == expected_output);

/// @brief Compiles a given file and expects compilation to succeed. The compiled program
///        is expected to have the given expected output.
///
/// @param `path` The path in which to compile and execute the program
/// @param `file` The file to compile
/// @param `expected_output` The expected output of the compiled program
def test_file_ok_in(str path, str file, str expected_output):
	(unused, cwd) := system_command("echo -n $(pwd)");
	(exit_code, output) := system_command($"cd {cwd}/{path}; flintc --file {file}");
	assert(exit_code == 0);
	assert(output == "");
	(exit_code, output) = system_command($"cd {cwd}/{path}; ./main");
	assert(exit_code == 0);
	if output != expected_output:
		print($"UNEXPECTED_EXE: output = '{output}'\n");
		print($"EXPECTED_EXE: output = '{expected_output}'\n");
	assert(output == expected_output);

/// @brief Compiles a given file and expects compilation to succeed. The compiled program
///        is not executed.
///
/// @param `file` The file to compile
def test_compiles(str file):
	(exit_code, output) := system_command($"flintc --file {file}");
	if exit_code != 0:
		print($"UNEXPECTED_CMP: exit_code = {exit_code}\n");
	assert(exit_code == 0);
	if output != "":
		print($"UNEXPECTED_CMP: output = '{output}'\n");
	assert(output == "");

/// @brief Compiles a given file and expects compilation to succeed. The compiled program
///        is not executed.
///
/// @param `path` The path in which to compile the program
/// @param `file` The file to compile
def test_compiles_in(str path, str file):
	(unused, cwd) := system_command("echo -n $(pwd)");
	(exit_code, output) := system_command($"cd {cwd}/{path}; flintc --file {file}");
	if exit_code != 0:
		print($"UNEXPECTED_CMP: exit_code = {exit_code}\n");
	assert(exit_code == 0);
	if output != "":
		print($"UNEXPECTED_CMP: output = '{output}'\n");
	assert(output == "");

/// @brief Compiles a given file and expects compilation to fail with an expected output
///
/// @param `file` The file to compile
/// @param `expected_output` The expected output of the compiler
def test_file_fail(str file, str expected_output):
	(exit_code, output) := system_command($"flintc --no-colors --file {file}");
	assert(exit_code == 1);
	assert(starts_with(output, expected_output));

/// @brief Executes a given command inside a subdirectory and expects a given output
///
/// @param `path` The path in which to execute the command
/// @param `file` The file to compile
/// @param `expected_output` The expected output of the failing compilation 
def test_file_fail_in(str path, str file, str expected_output):
	(unused, cwd) := system_command("echo -n $(pwd)");
	(exit_code, output) := system_command($"cd {cwd}/{path}; flintc --no-colors --file {file}");
	assert(exit_code == 1);
	assert(starts_with(output, expected_output));

/// @brief Executes a given command inside a subdirectory and expects a given output
///        It skips the first `n` lines of the output and only compares the rest of the output.
///        @asserts that `n` is at least 1
///
/// @param `path` The path in which to execute the command
/// @param `file` The file to compile
/// @param `n` The number of lines to skip before starting to check the output
/// @param `expected_output` The expected output of the failing compilation 
def test_file_fail_in(u32 n, str path, str file, str expected_output):
	assert(n >= 1);
	(unused, cwd) := system_command("echo -n $(pwd)");
	(exit_code, output) := system_command($"cd {cwd}/{path}; flintc --no-colors --file {file}");
	assert(exit_code == 1);
	u64 start_idx = 0;
	u64 lines_skipped = 0;
	for (idx, char) in output:
		if char == '\n':
			lines_skipped++;
			if lines_skipped == n:
				start_idx = idx + 1;
				break;
	assert(starts_with(output[start_idx..], expected_output));

/// @brief Tries to compile the given file, expecting compilation to succeed but the
///        compiled program to crash
///
/// @param `file` The file to compile
/// @param `expected_output` The expected output of the run program
def test_file_crash(str file, str expected_output):
	(exit_code, output) := system_command($"flintc --file {file}");
	assert(exit_code == 0);
	assert(output == "");
	(exit_code, output) = system_command("./main");
	assert(exit_code != 0);
	assert(output == expected_output);
