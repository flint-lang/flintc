#ifndef __GENERATOR_HPP__
#define __GENERATOR_HPP__

#include "lexer/builtins.hpp"
#include "parser/ast/call_node_base.hpp"
#include "parser/ast/definitions/function_node.hpp"
#include "parser/ast/expressions/binary_op_node.hpp"
#include "parser/ast/expressions/expression_node.hpp"
#include "parser/ast/expressions/literal_node.hpp"
#include "parser/ast/expressions/type_cast_node.hpp"
#include "parser/ast/expressions/unary_op_expression.hpp"
#include "parser/ast/expressions/variable_node.hpp"
#include "parser/ast/file_node.hpp"
#include "parser/ast/scope.hpp"
#include "parser/ast/statements/assignment_node.hpp"
#include "parser/ast/statements/catch_node.hpp"
#include "parser/ast/statements/declaration_node.hpp"
#include "parser/ast/statements/for_loop_node.hpp"
#include "parser/ast/statements/if_node.hpp"
#include "parser/ast/statements/return_node.hpp"
#include "parser/ast/statements/throw_node.hpp"
#include "parser/ast/statements/unary_op_statement.hpp"
#include "parser/ast/statements/while_node.hpp"
#include "resolver/resolver.hpp"

#include <llvm/IR/IRBuilder.h>
#include <llvm/IR/LLVMContext.h>
#include <llvm/IR/Module.h>
#include <llvm/Target/TargetMachine.h>

#include <string>
#include <unordered_map>
#include <utility>
#include <vector>

/// @class `Generator`
/// @brief The class which is responsible for the IR code generation
/// @note This class cannot be initialized and all functions within this class are static
class Generator {
  public:
    Generator() = delete;

    /// @function `generate_program_ir`
    /// @brief Generates the llvm IR code for a complete program
    ///
    /// @param `program_name` The name the program (the module) will have
    /// @param `context` The context used for generation
    /// @param `dep_graph` The root DepNode of the dependency graph
    /// @return `std::unique_ptr<llvm::Module>` A pointer containing the generated program module
    ///
    /// @attention Do not forget to call `Resolver::clear()` before the module returned from this function goes out of scope! You would get
    /// a segmentation fault if you were to forget that!
    static std::unique_ptr<llvm::Module> generate_program_ir( //
        const std::string &program_name,                      //
        llvm::LLVMContext &context,                           //
        std::shared_ptr<DepNode> &dep_graph                   //
    );

    /// @function `generate_file_ir`
    /// @brief Generates the llvm IR code for a single file and saves it into a llvm module
    ///
    /// @param `builder` The IR builder
    /// @param `context` The LLVM context
    /// @param `dep_node` The dependency graph node of the file (used for circular dependencies)
    /// @param `file` The file node to generate
    /// @return `std::unique_ptr<llvm::Module>` A pointer containing the generated file module
    static std::unique_ptr<llvm::Module> generate_file_ir( //
        llvm::IRBuilder<> *builder,                        //
        llvm::LLVMContext &context,                        //
        const std::shared_ptr<DepNode> &dep_node,          //
        const FileNode &file                               //
    );

    /// @function `get_module_ir_string`
    /// @brief Generates the IR code of the given Module and returns it as a string
    ///
    /// @param `module` The module whose IR code will be generated
    /// @return `std::string` The string containing the IR code of the module
    static std::string get_module_ir_string(const llvm::Module *module);

    /// @function `resolve_ir_comments`
    /// @brief Resolves all IR metadata within the given IR string and places comments where the metadata is located at
    ///
    /// @param `ir_string` The IR code where metadata will be resolved, and replaced by IR comments
    /// @return `std::string` The modified IR code, where all metadata is resolved into IR comments
    static std::string resolve_ir_comments(const std::string &ir_string);

  private:
    /// @var `builtins`
    /// @brief Map containing references to all builtin functions
    ///
    /// This map exists to track the references to all the builtin functions
    ///
    /// @details
    /// - **Key** `BuiltinFunctions` - The enum value of the builtin function to reference
    /// - **Value** `llvm::Function *` - The reference to the generated builtin function
    ///
    /// @attention The builtin functions are nullpointers until the explcitely are generated by their respecitve generation functions
    /// @attention Currently, no builtin functions are being generated yet, so there does not exist any reason to use this map yet
    /// @todo Remove the PRINT builtin function, as it has its own builtin functions, overloaded for every type (`print_functions`)
    static inline std::unordered_map<BuiltinFunction, llvm::Function *> builtins = {
        {BuiltinFunction::PRINT, nullptr},
        {BuiltinFunction::PRINT_ERR, nullptr},
        {BuiltinFunction::ASSERT, nullptr},
        {BuiltinFunction::ASSERT_ARG, nullptr},
        {BuiltinFunction::RUN_ON_ALL, nullptr},
        {BuiltinFunction::MAP_ON_ALL, nullptr},
        {BuiltinFunction::FILTER_ON_ALL, nullptr},
        {BuiltinFunction::REDUCE_ON_ALL, nullptr},
        {BuiltinFunction::REDUCE_ON_PAIRS, nullptr},
        {BuiltinFunction::PARTITION_ON_ALL, nullptr},
        {BuiltinFunction::SPLIT_ON_ALL, nullptr},
    };

    /// @var `print_functions`
    /// @brief Map containing references to all print function varaints
    ///
    /// This map exists to track the references to the builtin print functions. They are being created at the beginning of the program
    /// generation phase. Whenever a builtin print function is being refernced this map is used to resolve it.
    ///
    /// @details
    /// - **Key** `std::string` - The type of the print function
    /// - **Value** `llvm::Function *` - The reference to the genereated print function
    ///
    /// @attention The print functions are nullpointers until the `generate_builtin_prints` function is called
    /// @attention The map is not being cleared after the program module has been generated
    static inline std::unordered_map<std::string_view, llvm::Function *> print_functions = {
        {"i32", nullptr},
        {"i64", nullptr},
        {"u32", nullptr},
        {"u64", nullptr},
        {"f32", nullptr},
        {"f64", nullptr},
        {"flint", nullptr},
        {"char", nullptr},
        {"str", nullptr},
        {"bool", nullptr},
    };

    /// @var `type_map`
    /// @brief Map containing all possible struct return types of function calls
    ///
    /// This map exists in order to prevent re-creation of the same StructType for every function declaration and definition. It is used
    /// throughout the generation process to reference already created StructType types
    ///
    /// @details
    /// - **Key** `std::string` - The return type of the function, encoded as a string (for example 'int' or 'str' for single returns)
    /// - **Value** `llvm::StructType *` - The reference to the already existent StructType definition
    static std::unordered_map<std::string, llvm::StructType *> type_map;

    /// @var `unresolved_functions`
    /// @brief Stores unresolved function calls within a module.
    ///
    /// This data structure is used during the module generation process to track
    /// all unresolved function calls. These calls will be resolved at the end
    /// of the per-file module generation phase.
    ///
    /// @details
    /// - **Key:** `std::string` - Name of the called function.
    /// - **Value:** `std::vector<llvm::CallInst *>` - List of all calls to this function.
    ///
    /// @note This map is static and persists throughout the module's lifecycle.
    /// @attention Ensure that all entries in this map are processed and resolved
    /// before completing the module generation.
    static std::unordered_map<std::string, std::vector<llvm::CallInst *>> unresolved_functions;

    /// @var `file_unresolved_functions`
    /// @brief Stores all unresolved function calls towards a different file
    ///
    /// This data structure is used during the module generation process to track all unresolved
    /// inter-module function calls. These calls will be resolved at the end of the generation
    /// process, when all module's functions have been generated and have been added to the same
    /// main module.
    ///
    /// @details
    /// - **Key** `std::string` - Name of the file the call targets
    /// - **Value** `std::unordered_map<std::string, std::vector<llvm::CallInst *>>` -
    ///         The map of all unresolved function calls towards this file
    /// - - **Key** `std::string` - Name of the called function
    /// - - **Value** `std::vector<llvm::CallInst *>` - The list of all calls targeting this function
    ///
    /// @note This map is static and persists throughout the module's lifecyle
    static std::unordered_map<std::string, std::unordered_map<std::string, std::vector<llvm::CallInst *>>> file_unresolved_functions;

    /// @var `function_mangle_ids`
    /// @brief Stores all mangle IDs for all functions in the module currently being generated
    ///
    /// This data structure is used during the module generation process to track the mangle IDs of all functions within the module
    /// currently being generated. Because every function inside the generated module can appear in any order, all function definitions have
    /// to be forward-declared within the generated module, thus _every_ function inside the module does have a mangle ID
    ///
    /// @details
    /// - **Key** `std::string` - Name of the function
    /// - **Value** `unsigned int` - Manlge ID of the function
    ///
    /// @note This map is being cleared at the end of every file module generation pass
    static std::unordered_map<std::string, unsigned int> function_mangle_ids;

    /// @var `file_function_mangle_ids`
    /// @brief Stores all mangle ids for all functions from all files
    ///
    /// This data structure is used during the module generation process to track the mangle IDs of all functions of all generated
    /// files. It is used at the end of the main module generation to resolve all unresolved function calls between files.
    ///
    /// @details
    /// - **Key** `std::string` - Name of the file the functions are defined in
    /// - **Value** `std::unordered_map<std::string, unsigned int>` - The function mangle id map containing all ids of all functions
    ///
    /// @attention This map is never cleared so it is considered unsafe generating multiple programs within one lifetime of the program
    static std::unordered_map<std::string, std::unordered_map<std::string, unsigned int>> file_function_mangle_ids;

    /// @var `function_names`
    /// @brief A vector of all function names within the current file
    ///
    /// This data structure is used during the module generation process to track all names of functions inside the file currently being
    /// generated. This list is essential in checking if a function call is external or not, as currently only the functions names are
    /// important, not their types.
    ///
    /// @note This list of function names is cleared ad the end of every file module generation pass
    /// @todo Implement a more sophisticated system to detect extern calls which combines the functions name as well as its type when
    /// checking if the call is file-internal or external
    static std::vector<std::string> function_names;

    /// @var `file_function_names`
    /// @brief Stores all the lists of function names from every file
    ///
    /// This data structure is used during the module generation process to keep track of all function names across all files. It is
    /// important for checking to which file a call goes to when it is an extern call.
    ///
    /// @details
    /// - **Key** `std::string` - The name of the file the functions are located in
    /// - **Value** `std::vector<std::string>` - The list of function names within this file
    ///
    /// @attention This map is never cleared so it is considered unsafe generating multiple programs within one lifetime of the program
    /// @todo Implement a more sophisticated system to detect which extern function the call references by embedding the whole signature of
    /// the function the call references, not only its name
    static std::unordered_map<std::string, std::vector<std::string>> file_function_names;

    /// @var `main_call_array`
    /// @brief Holds a reference to the call of the user-defined main function from within the builtin main function
    ///
    /// This array of size 1 exists because a static variable is needed to reference the call instruction. If the pointer to the call
    /// instruction itself would have been made static, very weird things start to happen as the pointer seemingly "changes" its reference
    /// its pointing to. This is the reason the pointer, the value of this static construct, is being wrapped in an array of size 1. It
    /// introduces minimal overhead and only acts as a static "container" in this case, to store the pointer to the call instruction calling
    /// the user-defined main function from within the builtin main function.
    static std::array<llvm::CallInst *, 1> main_call_array;

    /// @var `main_module`
    /// @brief Holds a static reference to the main module
    ///
    /// This array of size 1 exists because of the same reasons as why 'main_call_array' exists. It holds the reference to the main
    /// module, which means that every function can reference the main module if needed without the main module needed to explicitely be
    /// passed around through many functions which dont use it annyways. It is actually much more efficient to have this reference inside an
    /// static array than to pass it around unnecessarily.
    static std::array<llvm::Module *, 1> main_module;

    /// @class `IR`
    /// @brief The class which is responsible for the utility functions for the IR generation
    /// @note This class cannot be initialized and all functions within this class are static
    class IR {
      public:
        // The constructor is deleted to make this class non-initializable
        IR() = delete;

        /// @function `add_and_or_get_type`
        /// @brief Checks if a given return type of a given FunctionNode already exists. If it exists, it returns a reference to it, if it
        /// does not exist it creates it and then returns a reference to the created StructType
        ///
        /// @param `context` The LLVM context
        /// @param `function_node` The FunctionNode whose return types will be analyzed
        /// @return `llvm::StructType *` The reference to the StructType, representing the return type of the given function
        static llvm::StructType *add_and_or_get_type(llvm::LLVMContext *context, const FunctionNode *function_node);

        /// @function `generate_forward_declarations`
        /// @brief Generates the forward-declarations of all constructs in the given FileNode, except the 'use' constructs to make another
        /// module able to use them. This function is also essential for Flint's support of circular dependency resolution
        ///
        /// @param `builder` The IR builder
        /// @param `module` The module the forward declarations are declared inside
        /// @param `file_node` The FileNode whose construct definitions will be forward-declared in the given module
        static void generate_forward_declarations(llvm::IRBuilder<> &builder, llvm::Module *module, const FileNode &file_node);

        /// @function `get_type_from_str`
        /// @brief Returns the llvm Type from a given string value
        ///
        /// @param `context` The LLVM context
        /// @param `str` The string representation of the type which is matched to get the correct type
        /// @return `llvm::Type *` A pointer to the correct llvm Type from the given string
        ///
        /// @throws ErrGenerating when the type could not be parsed from the string representation to a real type
        static llvm::Type *get_type_from_str(llvm::LLVMContext &context, const std::string &str);

        /// @function `get_default_value_of_type`
        /// @brief Returns the default value associated with a given Type
        ///
        /// @param `type` The Type from which the default value has to be returned
        /// @return `llvm::Value *` The default value of the given Type
        ///
        /// @throws ErrGenerating when the given Type has no default value available for it
        /// @todo Add more types to the function, currently it only works with int, flint and pointer types
        static llvm::Value *get_default_value_of_type(llvm::Type *type);

        /// @function `generate_pow_instruction`
        /// @brief Generates a pow instruction from the given llvm values
        ///
        /// @param `builder` The IR builder
        /// @param `parent` The function the instruction will be generated in
        /// @param `lhs` The lhs value of the pow instruction (the pow base)
        /// @param `rhs` The rhs value of the pow instruction (the pow exponent)
        /// @return `llvm::Value *` A pointer to the generated result value of the pow instruction
        ///
        /// @attention This function currently just returns a nullptr, dont use it yet!
        /// @todo Actually implement this function
        static llvm::Value *generate_pow_instruction( //
            llvm::IRBuilder<> &builder,               //
            llvm::Function *parent,                   //
            llvm::Value *lhs,                         //
            llvm::Value *rhs                          //
        );
    }; // subclass IR

    /// @class `Builtin`
    /// @brief The class which is responsible for generating all builtin functions
    /// @note This class cannot be initialized and all functions within this class are static
    class Builtin {
      public:
        // The constructor is deleted to make this class non-initializable
        Builtin() = delete;

        /// @function `generate_builtin_main`
        /// @brief Generates the builtin main function which calls the user defined main function
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `module` The LLVM Module the main function definition will be generated in
        static void generate_builtin_main(llvm::IRBuilder<> *builder, llvm::Module *module);

        /// @function `generate_builtin_prints`
        /// @brief Generates the builtin 'print()' function and its overloaded versions to utilize C IO calls of the IO C stdlib
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `module` The LLVM Module the print functions definitions will be generated in
        static void generate_builtin_prints(llvm::IRBuilder<> *builder, llvm::Module *module);

        /// @function `generate_builtin_print`
        /// @brief Helper function to generate the builtin print function for the specified type
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `module` The LLVM Module the print function definition will be generated in
        /// @param `type` The type of variable this print function expects
        /// @param `format` The C format string for the specified type (%i or %d for example)
        static void generate_builtin_print( //
            llvm::IRBuilder<> *builder,     //
            llvm::Module *module,           //
            const std::string &type,        //
            const std::string &format       //
        );

        /// @function `generate_builtin_print_bool`
        /// @brief Generates the builtin print_bool function which prints 'true' or 'false' depending on the bool value
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `module` The LLVM Module the print function definition will be generated in
        static void generate_builtin_print_bool(llvm::IRBuilder<> *builder, llvm::Module *module);
    }; // subclass Builtin

    /// @class `Arithmetic`
    /// @brief The class which is responsible for everything arithmetic-related
    /// @note This class cannot be initialized and all functions within this class are static
    class Arithmetic {
      public:
        // The constructor is deleted to make this class non-initializable
        Arithmetic() = delete;

        /**************************************************************************************************************************************
         * @region `I32` / `I64`
         *************************************************************************************************************************************/

        static llvm::Value *int_safe_add(llvm::IRBuilder<> &builder, llvm::Value *lhs, llvm::Value *rhs);

        static llvm::Value *int_safe_sub(llvm::IRBuilder<> &builder, llvm::Value *lhs, llvm::Value *rhs);

        static llvm::Value *int_safe_mul(llvm::IRBuilder<> &builder, llvm::Value *lhs, llvm::Value *rhs);

        static llvm::Value *int_safe_div(llvm::IRBuilder<> &builder, llvm::Value *lhs, llvm::Value *rhs);

        /**************************************************************************************************************************************
         * @region `U32` / `U64`
         *************************************************************************************************************************************/

        static llvm::Value *uint_safe_add(llvm::IRBuilder<> &builder, llvm::Value *lhs, llvm::Value *rhs);

        static llvm::Value *uint_safe_sub(llvm::IRBuilder<> &builder, llvm::Value *lhs, llvm::Value *rhs);

        static llvm::Value *uint_safe_mul(llvm::IRBuilder<> &builder, llvm::Value *lhs, llvm::Value *rhs);

        static llvm::Value *uint_safe_div(llvm::IRBuilder<> &builder, llvm::Value *lhs, llvm::Value *rhs);
    }; // subclass Arithmetic

    /// @class `Logical`
    /// @brief The class which is responsible for everything logical-related
    /// @note This class cannot be initialized and all functions within this class are static
    class Logical {
      public:
        // The constructor is deleted to make this class non-initializable
        Logical() = delete;

        /// @function `generate_not`
        /// @brief Inverts the given value. If the given value is a boolean, it creates a 'not' expression, otherwise it inverts all bits
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `value_to_negate` The value which is inverted
        /// @return `llvm::Value *` The inverted value
        static llvm::Value *generate_not(llvm::IRBuilder<> &builder, llvm::Value *value_to_negate);
    };

    /// @class `TypeCast`
    /// @brief The class which is responsilbe for everything type-casting related
    /// @note This class cannot be initialized and all functions within this class are static
    class TypeCast {
      public:
        // The constructor is deleted to make this class non-initializable
        TypeCast() = delete;

        /**************************************************************************************************************************************
         * @region `I32`
         *************************************************************************************************************************************/

        /// @function `i32_to_u32`
        /// @brief Converts an i32 value to a u32 value
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `int_value` The i32 value to convert
        /// @return `llvm::Value *` The converted u32 value
        static llvm::Value *i32_to_u32(llvm::IRBuilder<> &builder, llvm::Value *int_value);

        /// @function `i32_to_i64`
        /// @brief Converts an i32 value to an i64 value
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `int_value` The i32 value to convert
        /// @return `llvm::Value *` The converted i64 value
        static llvm::Value *i32_to_i64(llvm::IRBuilder<> &builder, llvm::Value *int_value);

        /// @function `i32_to_u64`
        /// @brief Converts an i32 value to a u64 value
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `int_value` The i32 value to convert
        /// @return `llvm::Value *` The converted u64 value
        static llvm::Value *i32_to_u64(llvm::IRBuilder<> &builder, llvm::Value *int_value);

        /// @function `i32_to_f32`
        /// @brief Converts a i32 value to a f32 value
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `int_value` The int value to convert
        /// @return `llvm::Value *` The converted f32 value
        static llvm::Value *i32_to_f32(llvm::IRBuilder<> &builder, llvm::Value *int_value);

        /// @function `i32_to_f64`
        /// @brief Converts an i32 value to a f64 value
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `int_value` The i32 value to convert
        /// @return `llvm::Value *` The converted f64 value
        static llvm::Value *i32_to_f64(llvm::IRBuilder<> &builder, llvm::Value *int_value);

        /**************************************************************************************************************************************
         * @region `U32`
         *************************************************************************************************************************************/

        /// @function `u32_to_i32`
        /// @brief Converts a u32 value to an i32 value
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `int_value` The u32 value to convert
        /// @return `llvm::Value *` The converted i32 value
        static llvm::Value *u32_to_i32(llvm::IRBuilder<> &builder, llvm::Value *int_value);

        /// @function `u32_to_i64`
        /// @brief Converts a u32 value to an i64 value
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `int_value` The u32 value to convert
        /// @return `llvm::Value *` The converted i64 value
        static llvm::Value *u32_to_i64(llvm::IRBuilder<> &builder, llvm::Value *int_value);

        /// @function `u32_to_u64`
        /// @brief Converts a u32 value to a u64 value
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `int_value` The u32 value to convert
        /// @return `llvm::Value *` The converted u64 value
        static llvm::Value *u32_to_u64(llvm::IRBuilder<> &builder, llvm::Value *int_value);

        /// @function `u32_to_f32`
        /// @brief Converts a u32 value to a f32 value
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `int_value` The u32 value to convert
        /// @return `llvm::Value *` The converted f32 value
        static llvm::Value *u32_to_f32(llvm::IRBuilder<> &builder, llvm::Value *int_value);

        /// @function `u32_to_f64`
        /// @brief Converts a u32 value to a f64 value
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `int_value` The u32 value to convert
        /// @return `llvm::Value *` The converted f64 value
        static llvm::Value *u32_to_f64(llvm::IRBuilder<> &builder, llvm::Value *int_value);

        /**************************************************************************************************************************************
         * @region `I64`
         *************************************************************************************************************************************/

        /// @function `i64_to_i32`
        /// @brief Converts an i64 value to an i32 value
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `int_value` The i64 value to convert
        /// @return `llvm::Value *` The converted i32 value
        static llvm::Value *i64_to_i32(llvm::IRBuilder<> &builder, llvm::Value *int_value);

        /// @function `i64_to_u32`
        /// @brief Converts an i64 value to a u32 value
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `int_value` The i64 value to convert
        /// @return `llvm::Value *` The converted u32 value
        static llvm::Value *i64_to_u32(llvm::IRBuilder<> &builder, llvm::Value *int_value);

        /// @function `i64_to_u64`
        /// @brief Converts an i64 value to a u64 value
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `int_value` The i64 value to convert
        /// @return `llvm::Value *` The converted u64 value
        static llvm::Value *i64_to_u64(llvm::IRBuilder<> &builder, llvm::Value *int_value);

        /// @function `i64_to_f32`
        /// @brief Converts an i64 value to a f32 value
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `int_value` The i64 value to convert
        /// @return `llvm::Value *` The converted f32 value
        static llvm::Value *i64_to_f32(llvm::IRBuilder<> &builder, llvm::Value *int_value);

        /// @function `i64_to_f64`
        /// @brief Converts an i64 value to a f64 value
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `int_value` The i64 value to convert
        /// @return `llvm::Value *` The converted f64 value
        static llvm::Value *i64_to_f64(llvm::IRBuilder<> &builder, llvm::Value *int_value);

        /**************************************************************************************************************************************
         * @region `U64`
         *************************************************************************************************************************************/

        /// @function `u64_to_i32`
        /// @brief Converts a u64 value to an i32 value
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `int_value` The u64 value to convert
        /// @return `llvm::Value *` The converted i32 value
        static llvm::Value *u64_to_i32(llvm::IRBuilder<> &builder, llvm::Value *int_value);

        /// @function `u64_to_u32`
        /// @brief Converts a u64 value to a u32 value
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `int_value` The u64 value to convert
        /// @return `llvm::Value *` The converted u32 value
        static llvm::Value *u64_to_u32(llvm::IRBuilder<> &builder, llvm::Value *int_value);

        /// @function `u64_to_i64`
        /// @brief Converts a u64 value to an i64 value
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `int_value` The u64 value to convert
        /// @return `llvm::Value *` The converted i64 value
        static llvm::Value *u64_to_i64(llvm::IRBuilder<> &builder, llvm::Value *int_value);

        /// @function `u64_to_f32`
        /// @brief Converts a u64 value to a f32 value
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `int_value` The u64 value to convert
        /// @return `llvm::Value *` The converted f32 value
        static llvm::Value *u64_to_f32(llvm::IRBuilder<> &builder, llvm::Value *int_value);

        /// @function `u64_to_f64`
        /// @brief Converts a u64 value to a f64 value
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `int_value` The u64 value to convert
        /// @return `llvm::Value *` The converted f64 value
        static llvm::Value *u64_to_f64(llvm::IRBuilder<> &builder, llvm::Value *int_value);

        /**************************************************************************************************************************************
         * @region `F32`
         *************************************************************************************************************************************/

        /// @function `f32_to_i32`
        /// @brief Converts a f32 value to an i32 value
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `float_value` The f32 value to convert
        /// @return `llvm::Value *` The converted i32 value
        static llvm::Value *f32_to_i32(llvm::IRBuilder<> &builder, llvm::Value *float_value);

        /// @function `f32_to_u32`
        /// @brief Converts a f32 value to a u32 value
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `float_value` The f32 value to convert
        /// @return `llvm::Value *` The converted u32 value
        static llvm::Value *f32_to_u32(llvm::IRBuilder<> &builder, llvm::Value *float_value);

        /// @function `f32_to_i64`
        /// @brief Converts a f32 value to an i64 value
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `float_value` The f32 value to convert
        /// @return `llvm::Value *` The converted i64 value
        static llvm::Value *f32_to_i64(llvm::IRBuilder<> &builder, llvm::Value *float_value);

        /// @function `f32_to_u64`
        /// @brief Converts a f32 value to a u64 value
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `float_value` The f32 value to convert
        /// @return `llvm::Value *` The converted u64 value
        static llvm::Value *f32_to_u64(llvm::IRBuilder<> &builder, llvm::Value *float_value);

        /// @function `f32_to_f64`
        /// @brief Converts a f32 value to a f64 value
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `float_value` The f32 value to convert
        /// @return `llvm::Value *` The converted f64 value
        static llvm::Value *f32_to_f64(llvm::IRBuilder<> &builder, llvm::Value *float_value);

        /**************************************************************************************************************************************
         * @region `F64`
         *************************************************************************************************************************************/

        /// @function `f64_to_i32`
        /// @brief Converts a f64 value to an i32 value
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `double_value` The f64 value to convert
        /// @return `llvm::Value *` The converted i32 value
        static llvm::Value *f64_to_i32(llvm::IRBuilder<> &builder, llvm::Value *double_value);

        /// @function `f64_to_u32`
        /// @brief Converts a f64 value to a u32 value
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `double_value` The f64 value to convert
        /// @return `llvm::Value *` The converted u32 value
        static llvm::Value *f64_to_u32(llvm::IRBuilder<> &builder, llvm::Value *double_value);

        /// @function `f64_to_i64`
        /// @brief Converts a f64 value to an i64 value
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `double_value` The f64 value to convert
        /// @return `llvm::Value *` The converted i64 value
        static llvm::Value *f64_to_i64(llvm::IRBuilder<> &builder, llvm::Value *double_value);

        /// @function `f64_to_u64`
        /// @brief Converts a f64 value to a u64 value
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `double_value` The f64 value to convert
        /// @return `llvm::Value *` The converted u64 value
        static llvm::Value *f64_to_u64(llvm::IRBuilder<> &builder, llvm::Value *double_value);

        /// @function `f64_to_f32`
        /// @brief Converts a f64 value to a f32 value
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `double_value` The f64 value to convert
        /// @return `llvm::Value *` The converted f32 value
        static llvm::Value *f64_to_f32(llvm::IRBuilder<> &builder, llvm::Value *double_value);
    }; // subclass TypeCast

    /// @class `Allocation`
    /// @brief The class which is responsible for everything allocation-related, like varaible preallocation
    /// @note This class cannot be initialized and all functions within this class are static
    class Allocation {
      public:
        // The constructor is deleted to make this class non-initializable
        Allocation() = delete;

        /// @function `generate_allocations`
        /// @brief Generates all allocations of the given scope recursively. Adds all AllocaInst pointer to the allocations map
        ///
        /// This function is meant to be called at the start of the generate_function function. This function goes through all statements
        /// and expressions recursively down the scope and enters every sub-scope too and generates all allocations of all function
        /// variables at the start of the function. This is done to make StackOverflows nearly impossible. Before this pre-allocation system
        /// for all variables was implemented, StackOverflows were common (when calling functions inside loops), caused by the creation of a
        /// return struct for every function call.
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `parent` The Function the allocations are generated in
        /// @param `allocations` The map of allocations, where in the key all information like scope ID, call ID, name, etc is encoded
        /// @param `scope` The Scope from which all allocations are collected and allocated at the start of the scope
        ///
        /// @attention The allocations map will be modified (new entries are added), but it will not be cleared. If you want a clear
        ///            allocations map before calling this function, you need to clear it yourself.
        ///
        /// @todo #1 Implement that all varaibles used by the for loop are preallocated too, for loops currently dont work
        static void generate_allocations(                                         //
            llvm::IRBuilder<> &builder,                                           //
            llvm::Function *parent,                                               //
            const Scope *scope,                                                   //
            std::unordered_map<std::string, llvm::AllocaInst *const> &allocations //
        );

        /// @funnction `generate_call_allcoations`
        /// @brief Generates the allocations for calls (The return struct, the error value and all return values)
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `parent` The function the allocations are generated in
        /// @param `allocations` The map of allocations, where in the key all information like scope ID, call ID, name, etc is encoded
        /// @param `call_node` The CallNode used to generate the allocations from
        /// @param `scope` The scope the allocation would take place in
        ///
        /// @attention The allocations map will be modified
        /// @attention The call_node variable will be modified
        static void generate_call_allocations(                                     //
            llvm::IRBuilder<> &builder,                                            //
            llvm::Function *parent,                                                //
            const Scope *scope,                                                    //
            std::unordered_map<std::string, llvm::AllocaInst *const> &allocations, //
            CallNodeBase *call_node                                                //
        );

        /// @function `generate_allocation`
        /// @brief Generates a custom allocation call. This is a helper function to make allocations easier
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `scope` The scope the allocation would take place in
        /// @param `allocations` The map of allocations, where in the key all information like scope ID, call ID, name, etc is encoded
        /// @param `alloca_name` The name of the allocation (its name in the allocations map)
        /// @param `type` The type of the allocation
        /// @param `ir_name` The name of the allocation, only important for the IR Code output
        /// @param `ir_comment` The comment the allocation gets, only important for the IR Code output
        static void generate_allocation(                                           //
            llvm::IRBuilder<> &builder,                                            //
            const Scope *scope,                                                    //
            std::unordered_map<std::string, llvm::AllocaInst *const> &allocations, //
            const std::string &alloca_name,                                        //
            llvm::Type *type,                                                      //
            const std::string &ir_name,                                            //
            const std::string &ir_comment                                          //
        );

        /// @function `generate_default_struct`
        /// @brief Allocates a struct and adds default values to every element of the struct
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `type` The type of the struct
        /// @param `name` The name of the allocation
        /// @param `ignore_first` If to skip setting any value of the first element of the struct (the error value)
        /// @return `llvm::AllocaInst *` A pointer to the allocated struct allocation, where (all) the elements contain default values
        ///
        /// @attention If 'ignore_first' is set, the first struct element (the error value) wont be set to its default value. This is
        ///            important for the cases where you want a default struct but set the error value yourself. For example, when throwing
        ///            an error you would want to generate a default struct return and then set the error value. By setting `ignore_first`,
        ///            you save on a few instructions, as the first value (error value) wont be set to anything by default.
        static llvm::AllocaInst *generate_default_struct( //
            llvm::IRBuilder<> &builder,                   //
            llvm::StructType *type,                       //
            const std::string &name,                      //
            bool ignore_first = false                     //
        );
    }; // subclass Allocation

    /// @class `Function`
    /// @brief The class which is responsible for generating everything related to functions
    /// @note This class cannot be initialized and all functions within this class are static
    class Function {
      public:
        // The constructor is deleted to make this class non-initializable
        Function() = delete;

        /// @function `generate_function_type`
        /// @brief Generates the type information of a given FunctionNode
        ///
        /// @param `context` The LLVM context the type is generated in
        /// @param `function_node` The FunctionNode used to generate the type
        /// @return `llvm::FunctionType *` A pointer to the generated FuntionType
        static llvm::FunctionType *generate_function_type(llvm::LLVMContext &context, FunctionNode *function_node);

        /// @function `generate_function`
        /// @brief Generates a function from a given FunctionNode
        ///
        /// @param `module` The LLVM Module the function will be generated in
        /// @param `function_node` The FunctionNode used to generate the function
        /// @return `llvm::Function *` A pointer to the generated Function
        static llvm::Function *generate_function(llvm::Module *module, FunctionNode *function_node);

        /// @function `get_function_definition`
        /// @brief Returns the function definition from the given CallNode or other values based on a few conditions
        ///
        /// In the "normal" execution case, this function returns a pointer to the definition from a given CallNode's call. But, there are
        /// some conditions. If the call is towards a builtin function, this function explicitely returns a nullptr on purpose. If the
        /// definition could not be found, this function returns a `std::nullopt`. The second variable determines whether the call targets a
        /// function inside the current module (false) or if it targets a function from another module (true).
        ///
        /// @param `parent` The Function the call happens in
        /// @param `call_node` The CallNode from which the actual function definition is tried to be found
        /// @return `std::pair<nullptr, false>` If the call targets a builtin function
        /// @return `std::pair<std::nullopt, false>` If the function definition could not be found
        /// @return `std::pair<std::optional<Function *>, bool>` In all other cases. The second variable always determines whether the call
        /// targets a function inside the current module (false) or if it targets a function in another module (true).
        static std::pair<std::optional<llvm::Function *>, bool> get_function_definition( //
            llvm::Function *parent,                                                      //
            const CallNodeBase *call_node                                                //
        );

        /// @function `function_has_return`
        /// @brief Checks if a given function has a return statement within its bodies instructions
        ///
        /// @param `function` The function to check
        /// @param `bool` True if the function has a return statement, false if not
        ///
        /// @todo Currently, this function does return true if a single block has a return statement, but does not check if the last, or all
        ///       blocks, have return statements. This needs to be changed to check if all blocks have a return statement, and possibly
        ///       return a list of all blocks not containing a termination instruction, like `br` or `ret`
        static bool function_has_return(llvm::Function *function);
    }; // subclass Function

    /// @class `Statement`
    /// @brief The class which is responsible for generating everything related to statements
    /// @note This class cannot be initialized and all functions within this class are static
    class Statement {
      public:
        // The constructor is deleted to make this class non-initializable
        Statement() = delete;

        /// @function `generate_statement`
        /// @brief Generates a single statement
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `parent` The function the statement will be generated in
        /// @param `scope` The scope the statement is being generated in
        /// @param `allocations` The map of all allocations (from the preallocation system) to track the AllocaInst instructions
        /// @param `statement` The statement which will be generated
        static void generate_statement(                                            //
            llvm::IRBuilder<> &builder,                                            //
            llvm::Function *parent,                                                //
            const Scope *scope,                                                    //
            std::unordered_map<std::string, llvm::AllocaInst *const> &allocations, //
            const std::unique_ptr<StatementNode> &statement                        //
        );

        /// @function `generate_body`
        /// @brief Generates a whole body
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `parent` The function the body will be generated in
        /// @param `scope` The scope containing the body which will be generated
        /// @param `allocations` The map of all allocations (from the preallocation system) to track the AllocaInst instructions
        static void generate_body(                                                //
            llvm::IRBuilder<> &builder,                                           //
            llvm::Function *parent,                                               //
            const Scope *scope,                                                   //
            std::unordered_map<std::string, llvm::AllocaInst *const> &allocations //
        );

        /// @function `generate_return_statement`
        /// @brief Generates the return statement from the given ReturnNode
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `parent` The function the return statement will be generated in
        /// @param `scope` The scope the return statement will be generated in
        /// @param `allocations` The map of all allocations (from the preallocation system) to track the AllocaInst instructions
        /// @param `return_node` The return node to generated
        static void generate_return_statement(                                     //
            llvm::IRBuilder<> &builder,                                            //
            llvm::Function *parent,                                                //
            const Scope *scope,                                                    //
            std::unordered_map<std::string, llvm::AllocaInst *const> &allocations, //
            const ReturnNode *return_node                                          //
        );

        /// @function `generate_throw_statement`
        /// @brief Generates the throw statement from the given ThrowNode
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `parent` The function the return statement will be generated in
        /// @param `scope` The scope the throw statement will be generated in
        /// @param `allocations` The map of all allocations (from the preallocation system) to track the AllocaInst instructions
        /// @param `throw_node` The throw node to generate
        static void generate_throw_statement(                                      //
            llvm::IRBuilder<> &builder,                                            //
            llvm::Function *parent,                                                //
            const Scope *scope,                                                    //
            std::unordered_map<std::string, llvm::AllocaInst *const> &allocations, //
            const ThrowNode *throw_node                                            //
        );

        /// @function `generate_if_blocks`
        /// @brief Generates all blocks of the if-chain
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `parent` The function the basic blocks will be created in
        /// @param `blocks` The list of all basic blocks which will be created
        /// @param `if_node` The if node containin ght whole if-chain to generate the BasicBlocks from
        static void generate_if_blocks(              //
            llvm::IRBuilder<> &builder,              //
            llvm::Function *parent,                  //
            std::vector<llvm::BasicBlock *> &blocks, //
            const IfNode *if_node                    //
        );

        /// @function `generate_if_statement`
        /// @brief Generates the if statement from the given IfNode
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `parent` The function the if chain will be generated in
        /// @param `allocations` The map of all allocations (from the preallocation system) to track the AllocaInst instructions
        /// @param `blocks` The list of all basic blocks the if bodies are contained in
        /// @param `nesting_level` The nesting level determines how "deep" one is inside the if-chain
        /// @param `if_node` The if node to generate
        static void generate_if_statement(                                         //
            llvm::IRBuilder<> &builder,                                            //
            llvm::Function *parent,                                                //
            std::unordered_map<std::string, llvm::AllocaInst *const> &allocations, //
            std::vector<llvm::BasicBlock *> &blocks,                               //
            unsigned int nesting_level,                                            //
            const IfNode *if_node                                                  //
        );

        /// @function `generate_while_loop`
        /// @brief Generates the while loop from the given WhileNode
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `parent` The function the while loop will be generated in
        /// @param `allocations` The map of all allocations (from the preallocation system) to track the AllocaInst instructions
        /// @param `while_node` The while node to generate
        static void generate_while_loop(                                           //
            llvm::IRBuilder<> &builder,                                            //
            llvm::Function *parent,                                                //
            std::unordered_map<std::string, llvm::AllocaInst *const> &allocations, //
            const WhileNode *while_node                                            //
        );

        /// @function `generate_for_loop`
        /// @brief Generates the for loop from the given ForLoopNode
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `parent` The function the for loop will be generated in
        /// @param `allocations` The map of all allocations (from the preallcation system) to track the AllocaInst instructions
        /// @param `for_node` The for loop node to generate
        static void generate_for_loop(                                             //
            llvm::IRBuilder<> &builder,                                            //
            llvm::Function *parent,                                                //
            std::unordered_map<std::string, llvm::AllocaInst *const> &allocations, //
            const ForLoopNode *for_node                                            //
        );

        /// @function `generate_catch_statement`
        /// @brief Generates the catch statement from the given CatchNode
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `parent` The function the catch statement will be generated in
        /// @param `scope` The scope the catch statement is contained in
        /// @param `allocations` The map of all allocations (from the preallocation system) to track the AllocaInst instructions
        /// @param `catch_node` The catch node to generate
        static void generate_catch_statement(                                      //
            llvm::IRBuilder<> &builder,                                            //
            llvm::Function *parent,                                                //
            const Scope *scope,                                                    //
            std::unordered_map<std::string, llvm::AllocaInst *const> &allocations, //
            const CatchNode *catch_node                                            //
        );

        /// @function `generate_declaration`
        /// @brief Generates the declaration from the given DeclarationNode
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `parent` The function the declaration will be generated in
        /// @param `scope` The scope the declaration is contained in
        /// @param `allocations` The map of all allocations (from the preallocation system) to track the AllocaInst instructions
        /// @param `declaration_node` The declaration node to generate
        static void generate_declaration(                                          //
            llvm::IRBuilder<> &builder,                                            //
            llvm::Function *parent,                                                //
            const Scope *scope,                                                    //
            std::unordered_map<std::string, llvm::AllocaInst *const> &allocations, //
            const DeclarationNode *declaration_node                                //
        );

        /// @function `generate_assignment`
        /// @brief Generates the assignment from the given AssignmentNode
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `parent` The function the assignment will be generated in
        /// @param `scope` The scope the assignment is contained in
        /// @param `allocations` The map of all allocations (from the preallocation system) to track the AllocaInst instructions
        /// @param `assignment_node` The assignment node to generate
        static void generate_assignment(                                           //
            llvm::IRBuilder<> &builder,                                            //
            llvm::Function *parent,                                                //
            const Scope *scope,                                                    //
            std::unordered_map<std::string, llvm::AllocaInst *const> &allocations, //
            const AssignmentNode *assignment_node                                  //
        );

        /// @function `generate_unary_op_statement`
        /// @brief Generates the unary operation value from the given UnaryOpStatement
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `parent` The function the unary operation is generated in
        /// @param `scope` The scope the binary operation is contained in
        /// @param `allocations` The map of all allocations (from the preallocation system) to track the AllocaInst instructions
        /// @param `unary_op` The unary operation to generate
        static void generate_unary_op_statement(                                   //
            llvm::IRBuilder<> &builder,                                            //
            llvm::Function *parent,                                                //
            const Scope *scope,                                                    //
            std::unordered_map<std::string, llvm::AllocaInst *const> &allocations, //
            const UnaryOpStatement *unary_op                                       //
        );
    }; // subclass Statement

    /// @class `Expression`
    /// @brief The class which is responsible for generating everything related to expressions
    /// @note This class cannot be initialized and all functions within this class are static
    class Expression {
      public:
        // The constructor is deleted to make this class non-initializable
        Expression() = delete;

        /// @function `generate_expression`
        /// @brief Generates an expression from the given ExpressionNode
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `parent` The function the expression will be generated in
        /// @param `scope` The scope the expression is contained in
        /// @param `allocations` The map of all allocations (from the preallocation system) to track the AllocaInst instructions
        /// @param `expression_node` The expression node to generate
        /// @return `llvm::Value *` The value containing the result of the expression
        static llvm::Value *generate_expression(                                   //
            llvm::IRBuilder<> &builder,                                            //
            llvm::Function *parent,                                                //
            const Scope *scope,                                                    //
            std::unordered_map<std::string, llvm::AllocaInst *const> &allocations, //
            const ExpressionNode *expression_node                                  //
        );

        /// @function `generate_literal`
        /// @brief Generates the literal value from the given LiteralNode
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `parent` The scope the literal is contained in
        /// @param `literal_node` The literal node to generate
        /// @return `llvm::Value *` The value containing the result of the literal
        static llvm::Value *generate_literal(llvm::IRBuilder<> &builder, llvm::Function *parent, const LiteralNode *literal_node);

        /// @function `generate_variable`
        /// @brief Generates the variable from the given VariableNode
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `parent` The function the variable is generated in
        /// @param `scope` The scope the variable is contained in
        /// @param `allocations` The map of all allocations (from the preallocation system) to track the AllocaInst instructions
        /// @param `variable_node` The variable node to generate
        /// @return `llvm::Value *` The value containing the result of the variable
        static llvm::Value *generate_variable(                                     //
            llvm::IRBuilder<> &builder,                                            //
            llvm::Function *parent,                                                //
            const Scope *scope,                                                    //
            std::unordered_map<std::string, llvm::AllocaInst *const> &allocations, //
            const VariableNode *variable_node                                      //
        );

        /// @function `generate_call`
        /// @brief Generates the call from the given CallNode
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `parent` The function the call is generated in
        /// @param `scope` The scope the call is contained in
        /// @param `allocations` The map of all allocations (from the preallocation system) to track the AllocaInst instructions
        /// @param `call_node` The call node to generate
        /// @return `llvm::Value *` The value containing the result of the call (this will be a struct)
        static llvm::Value *generate_call(                                         //
            llvm::IRBuilder<> &builder,                                            //
            llvm::Function *parent,                                                //
            const Scope *scope,                                                    //
            std::unordered_map<std::string, llvm::AllocaInst *const> &allocations, //
            const CallNodeBase *call_node                                          //
        );

        /// @function `generate_rethrow`
        /// @brief Generates a catch block which re-throws the error of the call, if the call had an error
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `parent` The function the rethrow is generated in
        /// @param `allocations` The map of all allocations (from the preallocation system) to track the AllocaInst instructions
        /// @param `call_node` The call node which is used to generate the rethrow from
        static void generate_rethrow(                                              //
            llvm::IRBuilder<> &builder,                                            //
            llvm::Function *parent,                                                //
            std::unordered_map<std::string, llvm::AllocaInst *const> &allocations, //
            const CallNodeBase *call_node                                          //
        );

        /// @function `generate_type_cast`
        /// @brief Generates a type cast from a TypeCastNode
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `parent` The function the type cast is generated in
        /// @param `scope` The scope the type cast is contained in
        /// @param `allocations` The map of all allocations (from the preallocation system) to track the AllocaInst instructions
        /// @param `type_cast_node` The type cast to generate
        /// @return `llvm::Value *` The value containing the result of the type cast
        static llvm::Value *generate_type_cast(                                    //
            llvm::IRBuilder<> &builder,                                            //
            llvm::Function *parent,                                                //
            const Scope *scope,                                                    //
            std::unordered_map<std::string, llvm::AllocaInst *const> &allocations, //
            const TypeCastNode *type_cast_node                                     //
        );

        /// @function `generate_type_cast`
        /// @brief Generates a type cast from the given expression depending on the from and to types
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `expr` The llvm value which will be cast
        /// @param `from_type` The string representation of the type to cast from
        /// @param `to_type` The string representation of the type to cast to
        /// @return `llvm::Value *` The value containing the result of the type cast
        static llvm::Value *generate_type_cast( //
            llvm::IRBuilder<> &builder,         //
            llvm::Value *expr,                  //
            const std::string &from_type,       //
            const std::string &to_type          //
        );

        /// @function `generate_unary_op_expression`
        /// @brief Generates the unary operation value from the given UnaryOpNode
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `parent` The function the unary operation is generated in
        /// @param `scope` The scope the binary operation is contained in
        /// @param `allocations` The map of all allocations (from the preallocation system) to track the AllocaInst instructions
        /// @param `unary_op` The unary operation to generate
        /// @return `llvm::Value *` The value containing the result of the unary operation
        static llvm::Value *generate_unary_op_expression(                          //
            llvm::IRBuilder<> &builder,                                            //
            llvm::Function *parent,                                                //
            const Scope *scope,                                                    //
            std::unordered_map<std::string, llvm::AllocaInst *const> &allocations, //
            const UnaryOpExpression *unary_op                                      //
        );

        /// @function `generate_binary_op`
        /// @brief Generates a binary operation from the given BinaryOpNode
        ///
        /// @param `builder` The LLVM IRBuilder
        /// @param `parent` The function the binary operation is generated in
        /// @param `scope` The scope the binary operation is contained in
        /// @param `allocations` The map of all allocations (from the preallocation system) to track the AllocaInst instructions
        /// @param `bin_op_node` The binary operation to generate
        /// @return `llvm::Value *` The value containing the result of the binop
        static llvm::Value *generate_binary_op(                                    //
            llvm::IRBuilder<> &builder,                                            //
            llvm::Function *parent,                                                //
            const Scope *scope,                                                    //
            std::unordered_map<std::string, llvm::AllocaInst *const> &allocations, //
            const BinaryOpNode *bin_op_node                                        //
        );
    }; // subclass Expression
};

#endif
