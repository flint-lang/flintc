#ifndef __GENERATOR_HPP__
#define __GENERATOR_HPP__

#include "lexer/lexer.hpp"
#include "parser/ast/definitions/function_node.hpp"
#include "parser/ast/expressions/binary_op_node.hpp"
#include "parser/ast/expressions/call_node.hpp"
#include "parser/ast/expressions/expression_node.hpp"
#include "parser/ast/expressions/literal_node.hpp"
#include "parser/ast/expressions/unary_op_node.hpp"
#include "parser/ast/expressions/variable_node.hpp"
#include "parser/ast/file_node.hpp"
#include "parser/ast/scope.hpp"
#include "parser/ast/statements/assignment_node.hpp"
#include "parser/ast/statements/catch_node.hpp"
#include "parser/ast/statements/declaration_node.hpp"
#include "parser/ast/statements/for_loop_node.hpp"
#include "parser/ast/statements/if_node.hpp"
#include "parser/ast/statements/return_node.hpp"
#include "parser/ast/statements/throw_node.hpp"
#include "parser/ast/statements/while_node.hpp"
#include "resolver/resolver.hpp"
#include "types.hpp"

#include <llvm/IR/IRBuilder.h>
#include <llvm/IR/LLVMContext.h>
#include <llvm/IR/Module.h>
#include <llvm/Target/TargetMachine.h>

#include <string>
#include <unordered_map>
#include <utility>
#include <vector>

/// @class `Generator`
/// @brief The class which is responsible for the IR code generation
/// @note This class cannot be initialized and all functions within this class are static
class Generator {
  public:
    Generator() = delete;

    /// @function `generate_program_ir`
    /// @brief Generates the llvm IR code for a complete program
    ///
    /// @param `program_name` The name the program (the module) will have
    /// @param `context` The context used for generation
    /// @param `dep_graph` The root DepNode of the dependency graph
    /// @return `std::unique_ptr<llvm::Module>` A pointer containing the generated program module
    ///
    /// @attention Do not forget to call `Resolver::clear()` before the module returned from this function goes out of scope! You would get
    /// a segmentation fault if you were to forget that!
    static std::unique_ptr<llvm::Module> generate_program_ir( //
        const std::string &program_name,                      //
        llvm::LLVMContext &context,                           //
        std::shared_ptr<DepNode> &dep_graph                   //
    );

    /// @function `generate_file_ir`
    /// @brief Generates the llvm IR code for a single file and saves it into a llvm module
    ///
    /// @param `builder` The IR builder
    /// @param `context` The LLVM context
    /// @param `dep_node` The dependency graph node of the file (used for circular dependencies)
    /// @param `file` The file node to generate
    /// @return `std::unique_ptr<llvm::Module>` A pointer containing the generated file module
    static std::unique_ptr<llvm::Module> generate_file_ir( //
        llvm::IRBuilder<> *builder,                        //
        llvm::LLVMContext &context,                        //
        const std::shared_ptr<DepNode> &dep_node,          //
        const FileNode &file                               //
    );

    /// @function `get_module_ir_string`
    /// @brief Generates the IR code of the given Module and returns it as a string
    ///
    /// @param `module` The module whose IR code will be generated
    /// @return `std::string` The string containing the IR code of the module
    static std::string get_module_ir_string(const llvm::Module *module);

    /// @function `resolve_ir_comments`
    /// @brief Resolves all IR metadata within the given IR string and places comments where the metadata is located at
    ///
    /// @param `ir_string` The IR code where metadata will be resolved, and replaced by IR comments
    /// @return `std::string` The modified IR code, where all metadata is resolved into IR comments
    static std::string resolve_ir_comments(const std::string &ir_string);

  private:
    /// @var `builtins`
    /// @brief Map containing references to all builtin functions
    ///
    /// This map exists to track the references to all the builtin functions
    ///
    /// @details
    /// - **Key** `BuiltinFunctions` - The enum value of the builtin function to reference
    /// - **Value** `llvm::Function *` - The reference to the generated builtin function
    ///
    /// @attention The builtin functions are nullpointers until the explcitely are generated by their respecitve generation functions
    /// @attention Currently, no builtin functions are being generated yet, so there does not exist any reason to use this map yet
    /// @todo Remove the PRINT builtin function, as it has its own builtin functions, overloaded for every type (`print_functions`)
    static inline std::unordered_map<BuiltinFunctions, llvm::Function *> builtins = {
        {BuiltinFunctions::PRINT, nullptr},
        {BuiltinFunctions::PRINT_ERR, nullptr},
        {BuiltinFunctions::ASSERT, nullptr},
        {BuiltinFunctions::ASSERT_ARG, nullptr},
        {BuiltinFunctions::RUN_ON_ALL, nullptr},
        {BuiltinFunctions::MAP_ON_ALL, nullptr},
        {BuiltinFunctions::FILTER_ON_ALL, nullptr},
        {BuiltinFunctions::REDUCE_ON_ALL, nullptr},
        {BuiltinFunctions::REDUCE_ON_PAIRS, nullptr},
        {BuiltinFunctions::PARTITION_ON_ALL, nullptr},
        {BuiltinFunctions::SPLIT_ON_ALL, nullptr},
    };

    /// @var `print_functions`
    /// @brief Map containing references to all print function varaints
    ///
    /// This map exists to track the references to the builtin print functions. They are being created at the beginning of the program
    /// generation phase. Whenever a builtin print function is being refernced this map is used to resolve it.
    ///
    /// @details
    /// - **Key** `std::string` - The type of the print function
    /// - **Value** `llvm::Function *` - The reference to the genereated print function
    ///
    /// @attention The print functions are nullpointers until the `generate_builtin_prints` function is called
    /// @attention The map is not being cleared after the program module has been generated
    static inline std::unordered_map<std::string, llvm::Function *> print_functions = {
        {"int", nullptr},
        {"flint", nullptr},
        {"char", nullptr},
        {"str", nullptr},
        {"bool", nullptr},
        {"byte", nullptr},
    };

    /// @var `type_map`
    /// @brief Map containing all possible struct return types of function calls
    ///
    /// This map exists in order to prevent re-creation of the same StructType for every function declaration and definition. It is used
    /// throughout the generation process to reference already created StructType types
    ///
    /// @details
    /// - **Key** `std::string` - The return type of the function, encoded as a string (for example 'int' or 'str' for single returns)
    /// - **Value** `llvm::StructType *` - The reference to the already existent StructType definition
    static std::unordered_map<std::string, llvm::StructType *> type_map;

    static llvm::StructType *add_and_or_get_type(llvm::LLVMContext *context, const FunctionNode *function_node);
    static std::pair<std::optional<llvm::Function *>, bool> get_function_definition(llvm::Function *parent, const CallNode *call_node);
    static void generate_builtin_main(llvm::IRBuilder<> *builder, llvm::Module *module);
    static void generate_forward_declarations(llvm::IRBuilder<> &builder, llvm::Module *module, const FileNode &file_node);

    /// @var `unresolved_functions`
    /// @brief Stores unresolved function calls within a module.
    ///
    /// This data structure is used during the module generation process to track
    /// all unresolved function calls. These calls will be resolved at the end
    /// of the per-file module generation phase.
    ///
    /// @details
    /// - **Key:** `std::string` - Name of the called function.
    /// - **Value:** `std::vector<llvm::CallInst *>` - List of all calls to this function.
    ///
    /// @note This map is static and persists throughout the module's lifecycle.
    /// @attention Ensure that all entries in this map are processed and resolved
    /// before completing the module generation.
    static std::unordered_map<std::string, std::vector<llvm::CallInst *>> unresolved_functions;

    /// @var `file_unresolved_functions`
    /// @brief Stores all unresolved function calls towards a different file
    ///
    /// This data structure is used during the module generation process to track all unresolved
    /// inter-module function calls. These calls will be resolved at the end of the generation
    /// process, when all module's functions have been generated and have been added to the same
    /// main module.
    ///
    /// @details
    /// - **Key** `std::string` - Name of the file the call targets
    /// - **Value** `std::unordered_map<std::string, std::vector<llvm::CallInst *>>` -
    ///         The map of all unresolved function calls towards this file
    /// - - **Key** `std::string` - Name of the called function
    /// - - **Value** `std::vector<llvm::CallInst *>` - The list of all calls targeting this function
    ///
    /// @note This map is static and persists throughout the module's lifecyle
    static std::unordered_map<std::string, std::unordered_map<std::string, std::vector<llvm::CallInst *>>> file_unresolved_functions;

    /// @var `function_mangle_ids`
    /// @brief Stores all mangle IDs for all functions in the module currently being generated
    ///
    /// This data structure is used during the module generation process to track the mangle IDs of all functions within the module
    /// currently being generated. Because every function inside the generated module can appear in any order, all function definitions have
    /// to be forward-declared within the generated module, thus _every_ function inside the module does have a mangle ID
    ///
    /// @details
    /// - **Key** `std::string` - Name of the function
    /// - **Value** `unsigned int` - Manlge ID of the function
    ///
    /// @note This map is being cleared at the end of every file module generation pass
    static std::unordered_map<std::string, unsigned int> function_mangle_ids;

    /// @var `file_function_mangle_ids`
    /// @brief Stores all mangle ids for all functions from all files
    ///
    /// This data structure is used during the module generation process to track the mangle IDs of all functions of all generated
    /// files. It is used at the end of the main module generation to resolve all unresolved function calls between files.
    ///
    /// @details
    /// - **Key** `std::string` - Name of the file the functions are defined in
    /// - **Value** `std::unordered_map<std::string, unsigned int>` - The function mangle id map containing all ids of all functions
    ///
    /// @attention This map is never cleared so it is considered unsafe generating multiple programs within one lifetime of the program
    static std::unordered_map<std::string, std::unordered_map<std::string, unsigned int>> file_function_mangle_ids;

    /// @var `function_names`
    /// @brief A vector of all function names within the current file
    ///
    /// This data structure is used during the module generation process to track all names of functions inside the file currently being
    /// generated. This list is essential in checking if a function call is external or not, as currently only the functions names are
    /// important, not their types.
    ///
    /// @note This list of function names is cleared ad the end of every file module generation pass
    /// @todo Implement a more sophisticated system to detect extern calls which combines the functions name as well as its type when
    /// checking if the call is file-internal or external
    static std::vector<std::string> function_names;

    /// @var `file_function_names`
    /// @brief Stores all the lists of function names from every file
    ///
    /// This data structure is used during the module generation process to keep track of all function names across all files. It is
    /// important for checking to which file a call goes to when it is an extern call.
    ///
    /// @details
    /// - **Key** `std::string` - The name of the file the functions are located in
    /// - **Value** `std::vector<std::string>` - The list of function names within this file
    ///
    /// @attention This map is never cleared so it is considered unsafe generating multiple programs within one lifetime of the program
    /// @todo Implement a more sophisticated system to detect which extern function the call references by embedding the whole signature of
    /// the function the call references, not only its name
    static std::unordered_map<std::string, std::vector<std::string>> file_function_names;

    /// main_call_array
    ///     Holds a static reference to a single call instance, being the call of the custom main function
    ///     Is an array of size 1 to only have the container static, not the pointer (would lead to bugs otherwise)

    /// @var `main_call_array`
    /// @brief Holds a reference to the call of the user-defined main function from within the builtin main function
    ///
    /// This array of size 1 exists because a static variable is needed to reference the call instruction. If the pointer to the call
    /// instruction itself would have been made static, very weird things start to happen as the pointer seemingly "changes" its reference
    /// its pointing to. This is the reason the pointer, the value of this static construct, is being wrapped in an array of size 1. It
    /// introduces minimal overhead and only acts as a static "container" in this case, to store the pointer to the call instruction calling
    /// the user-defined main function from within the builtin main function.
    static std::array<llvm::CallInst *, 1> main_call_array;

    /// @var `main_module`
    /// @brief Holds a static reference to the main module
    ///
    /// This array of size 1 exists because of the same reasons as why 'main_call_array' exists. It holds the reference to the main module,
    /// which means that every function can reference the main module if needed without the main module needed to explicitely be passed
    /// around through many functions which dont use it annyways. It is actually much more efficient to have this reference inside an static
    /// array than to pass it around unnecessarily.
    static std::array<llvm::Module *, 1> main_module;

    static void generate_builtin_prints(llvm::IRBuilder<> *builder, llvm::Module *module);
    static void generate_builtin_print( //
        llvm::IRBuilder<> *builder,     //
        llvm::Module *module,           //
        const std::string &type,        //
        const std::string &format       //
    );
    static void generate_builtin_print_bool(llvm::IRBuilder<> *builder, llvm::Module *module);

    static llvm::Value *generate_pow_instruction(llvm::IRBuilder<> &builder, llvm::Function *parent, llvm::Value *lhs, llvm::Value *rhs);

    static bool function_has_return(llvm::Function *function);
    static void generate_phi_calls(                                                                            //
        llvm::IRBuilder<> &builder,                                                                            //
        std::unordered_map<std::string, std::vector<std::pair<llvm::BasicBlock *, llvm::Value *>>> &phi_lookup //
    );
    static void generate_call_allocations(                                     //
        llvm::IRBuilder<> &builder,                                            //
        llvm::Function *parent,                                                //
        Scope *scope,                                                          //
        std::unordered_map<std::string, llvm::AllocaInst *const> &allocations, //
        CallNode *call_node                                                    //
    );
    static void generate_allocation(                                           //
        llvm::IRBuilder<> &builder,                                            //
        Scope *scope,                                                          //
        std::unordered_map<std::string, llvm::AllocaInst *const> &allocations, //
        const std::string &alloca_name,                                        //
        llvm::Type *type,                                                      //
        const std::string &ir_name,                                            //
        const std::string &ir_comment                                          //
    );
    static void generate_allocations(                                         //
        llvm::IRBuilder<> &builder,                                           //
        llvm::Function *parent,                                               //
        Scope *scope,                                                         //
        std::unordered_map<std::string, llvm::AllocaInst *const> &allocations //
    );
    static llvm::Type *get_type_from_str(llvm::LLVMContext &context, const std::string &str);
    static llvm::Value *get_default_value_of_type(llvm::Type *type);
    static llvm::AllocaInst *generate_default_struct( //
        llvm::IRBuilder<> &builder,                   //
        llvm::StructType *type,                       //
        const std::string &name,                      //
        bool ignore_first = false                     //
    );

    static llvm::FunctionType *generate_function_type(llvm::LLVMContext &context, FunctionNode *function_node);
    static llvm::Function *generate_function(llvm::Module *module, FunctionNode *function_node);
    static void generate_body(                                                                                  //
        llvm::IRBuilder<> &builder,                                                                             //
        llvm::Function *parent,                                                                                 //
        Scope *scope,                                                                                           //
        std::unordered_map<std::string, std::vector<std::pair<llvm::BasicBlock *, llvm::Value *>>> &phi_lookup, //
        std::unordered_map<std::string, llvm::AllocaInst *const> &allocations                                   //
    );

    static void generate_statement(                                                                             //
        llvm::IRBuilder<> &builder,                                                                             //
        llvm::Function *parent,                                                                                 //
        Scope *scope,                                                                                           //
        const body_statement &statement,                                                                        //
        std::unordered_map<std::string, std::vector<std::pair<llvm::BasicBlock *, llvm::Value *>>> &phi_lookup, //
        std::unordered_map<std::string, llvm::AllocaInst *const> &allocations                                   //
    );
    static void generate_return_statement(                                    //
        llvm::IRBuilder<> &builder,                                           //
        llvm::Function *parent,                                               //
        Scope *scope,                                                         //
        const ReturnNode *return_node,                                        //
        std::unordered_map<std::string, llvm::AllocaInst *const> &allocations //
    );
    static void generate_throw_statement(                                     //
        llvm::IRBuilder<> &builder,                                           //
        llvm::Function *parent,                                               //
        Scope *scope,                                                         //
        const ThrowNode *throw_node,                                          //
        std::unordered_map<std::string, llvm::AllocaInst *const> &allocations //
    );
    static void generate_if_statement(                                                                          //
        llvm::IRBuilder<> &builder,                                                                             //
        llvm::Function *parent,                                                                                 //
        const IfNode *if_node,                                                                                  //
        unsigned int nesting_level,                                                                             //
        const std::vector<llvm::BasicBlock *> &blocks,                                                          //
        std::unordered_map<std::string, std::vector<std::pair<llvm::BasicBlock *, llvm::Value *>>> &phi_lookup, //
        std::unordered_map<std::string, llvm::AllocaInst *const> &allocations                                   //
    );
    static void generate_while_loop(                                          //
        llvm::IRBuilder<> &builder,                                           //
        llvm::Function *parent,                                               //
        const WhileNode *while_node,                                          //
        std::unordered_map<std::string, llvm::AllocaInst *const> &allocations //
    );
    static void generate_for_loop(llvm::IRBuilder<> &builder, llvm::Function *parent, const ForLoopNode *for_node);
    static void generate_catch_statement(                                     //
        llvm::IRBuilder<> &builder,                                           //
        llvm::Function *parent,                                               //
        Scope *scope,                                                         //
        const CatchNode *catch_node,                                          //
        std::unordered_map<std::string, llvm::AllocaInst *const> &allocations //
    );
    static void generate_assignment(                                                                            //
        llvm::IRBuilder<> &builder,                                                                             //
        llvm::Function *parent,                                                                                 //
        Scope *scope,                                                                                           //
        const AssignmentNode *assignment_node,                                                                  //
        std::unordered_map<std::string, std::vector<std::pair<llvm::BasicBlock *, llvm::Value *>>> &phi_lookup, //
        std::unordered_map<std::string, llvm::AllocaInst *const> &allocations                                   //
    );
    static void generate_declaration(                                         //
        llvm::IRBuilder<> &builder,                                           //
        llvm::Function *parent,                                               //
        Scope *scope,                                                         //
        const DeclarationNode *declaration_node,                              //
        std::unordered_map<std::string, llvm::AllocaInst *const> &allocations //
    );

    static llvm::Value *generate_expression(                                  //
        llvm::IRBuilder<> &builder,                                           //
        llvm::Function *parent,                                               //
        Scope *scope,                                                         //
        const ExpressionNode *expression_node,                                //
        std::unordered_map<std::string, llvm::AllocaInst *const> &allocations //
    );
    static llvm::Value *generate_variable(                                    //
        llvm::IRBuilder<> &builder,                                           //
        llvm::Function *parent,                                               //
        Scope *scope,                                                         //
        const VariableNode *variable_node,                                    //
        std::unordered_map<std::string, llvm::AllocaInst *const> &allocations //
    );
    static llvm::Value *generate_unary_op(llvm::IRBuilder<> &builder, llvm::Function *parent, const UnaryOpNode *unary_op_node);
    static llvm::Value *generate_literal(llvm::IRBuilder<> &builder, llvm::Function *parent, const LiteralNode *literal_node);
    static llvm::Value *generate_call(                                        //
        llvm::IRBuilder<> &builder,                                           //
        llvm::Function *parent,                                               //
        Scope *scope,                                                         //
        const CallNode *call_node,                                            //
        std::unordered_map<std::string, llvm::AllocaInst *const> &allocations //
    );
    static void generate_rethrow(                                             //
        llvm::IRBuilder<> &builder,                                           //
        llvm::Function *parent,                                               //
        const CallNode *call_node,                                            //
        std::unordered_map<std::string, llvm::AllocaInst *const> &allocations //
    );
    static llvm::Value *generate_binary_op(                                   //
        llvm::IRBuilder<> &builder,                                           //
        llvm::Function *parent,                                               //
        Scope *scope,                                                         //
        const BinaryOpNode *bin_op_node,                                      //
        std::unordered_map<std::string, llvm::AllocaInst *const> &allocations //
    );
};

#endif
